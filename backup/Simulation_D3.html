<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    body {
        width: 100%;
        display: flex;
        margin: 0; padding: 0;
        font-family: sans-serif;
        font-size: 75%;
    }
    .controls{
        flex-basis: 200px;
        padding: 0 5px;
    }
    .controls .control {
        background-color: #eee;
        border-radius: 3px;
        padding: 5px;
        margin: 5px 0;
    }
    .controls input[type="checkbox"] { transform: scale(1.2, 1.2);}
    .controls input[type="range"] {margin: 0 5% 0.5em 5%; width: 90%;}
    .controls input[type="text"] {width: 30px;}
    .controls input[type="number"] {width: 30px;}
    .controls .control label { display: inline-block; }
    .controls .control p label { margin-right: .5em; font-size: 120%; font-weight: bold;}
    .controls .control p { margin-top: 0;}

    .space_group {
        border: 1px solid black;
        overflow-x: auto;
    }
    .space_group div{
        float: left;
    }
    .space_group .subspace {float: right;}
    .subspace p { margin: 0; font-size: 100%; text-align: center; font-weight: bold;}
    svg {
        border:1px solid black;
        margin: 5px;
    }
    table {
        border: 1px solid;
    }
    tr {
        border: 1px solid;
    }
    td {
        border: 1px solid;
    }
</style>
<body>
<div class="controls">
    <div class="control">
        <p><label>Population statistics</label>Target population number, initial patient, etc.</p>
        <label>Target population number: <output id="node_num_output">100</output> people
            <input type="range" min="1" max="500" value="100" step="1" oninput="d3.select('#node_num_output').text(value);">
        </label>
        <label>Initial patient: <output id="initial_patient_output">5</output> people
            <input type="range" min="1" max="100" value="5" step="1" oninput="d3.select('#initial_patient_output').text(value);">
        </label>
        <label>Initial speed: <output id="initial_speed_output">1.5</output>
            <input type="range" min="0" max="10" value="1.5" step="0.01" oninput="d3.select('#initial_speed_output').text(value);">
        </label>
        <label>Size: <output id="size_output">5</output>
            <input type="range" min="0" max="10" value="5" step="0.1" oninput="d3.select('#size_output').text(value);">
        </label>
    </div>
    <div class="control">
        <p><label>COVID variables</label>Latent period, duration, transmission rate</p>
        <label>Minimum latent period:
            <output id="latent_period_min_output">4.78</output> days (sec)
            <input type="range" min="1" max="30" value="4.78" step="0.01" oninput="d3.select('#latent_period_min_output').text(value);">
        </label>
        <label>Maximum latent period:
            <output id="latent_period_max_output">6.59</output> days (sec)
            <input type="range" min="1" max="30" value="6.59" step="0.01" oninput="d3.select('#latent_period_max_output').text(value);">
        </label>
        <label>Minimum duration:
            <output id="duration_min_output">13.69</output> days (sec)
            <input type="range" min="1" max="30" value="13.69" step="0.01" oninput="d3.select('#duration_min_output').text(value);">
        </label>
        <label>Maximum duration:
            <output id="duration_max_output">23.41</output> days (sec)
            <input type="range" min="1" max="30" value="23.41" step="0.01" oninput="d3.select('#duration_max_output').text(value);">
        </label>
        <label>Base transmission rate: <output id="transmission_rate_output">0.5</output> transmissions per contact
            <input type="range" min="0" max="1" value="0.5" step="0.01" oninput="d3.select('#transmission_rate_output').text(value);">
        </label>
    </div>
    <div class="control">
        <p><label>Response policies</label>Wearing mask, social distancing, hospitalization</p>
        <label>Wearing mask ratio:
            <output id="mask_ratio_output">0.5</output>
            <input type="range" min="0" max="1" value="0.5" step="0.01" oninput="d3.select('#mask_ratio_output').text(value);">
        </label>
        <label>Social distancing strength:
            <output id="social_distancing_output">1.5</output>
            <input type="range" min="0" max="10" value="1.5" step="0.01" oninput="d3.select('#social_distancing_output').text(value);">
        </label>
        <label>Hospitalization rate:
            <output id="hospitalization_output">0.5</output>
            <input type="range" min="0" max="1" value="0.5" step="0.01" oninput="d3.select('#hospitalization_output').text(value);">
        </label>
    </div>
    <div class="control">
        <label>Age distribution:
            <table>
                <tr><th>Age groups</th><th>10s</th><th>20s</th><th>30s</th><th>40s</th><th>50s</th><th>60s</th><th>70s</th></tr>
                <tr><th>Population</th>
                    <th><input type="text" id="pop_10" value="10"></th>
                    <th><input type="text" id="pop_20" value="10"></th>
                    <th><input type="text" id="pop_30" value="10"></th>
                    <th><input type="text" id="pop_40" value="10"></th>
                    <th><input type="text" id="pop_50" value="10"></th>
                    <th><input type="text" id="pop_60" value="10"></th>
                    <th><input type="text" id="pop_70" value="10"></th>
                </tr>
                <tr><th>Vulnerability</th>
                    <th><input type="number" id="Imm_10" min="0" max="1" value="1" step="0.1"></th>
                    <th><input type="number" id="Imm_20" min="0" max="1" value="1" step="0.1"></th>
                    <th><input type="number" id="Imm_30" min="0" max="1" value="1" step="0.1"></th>
                    <th><input type="number" id="Imm_40" min="0" max="1" value="1" step="0.1"></th>
                    <th><input type="number" id="Imm_50" min="0" max="1" value="1" step="0.1"></th>
                    <th><input type="number" id="Imm_60" min="0" max="1" value="1" step="0.1"></th>
                    <th><input type="number" id="Imm_70" min="0" max="1" value="1" step="0.1"></th>
                </tr>
            </table>
        </label>
    </div>
    <div class="control">
        <label>Simulation
            <input type="button" onclick="start_simulation()" value="Start">
            <input type="button" onclick="stop_simulation()" value="Stop">
            <input type="button" onclick="reset_simulation()" value="Reset">
        </label>
    </div>
</div>
</body>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="//unpkg.com/d3-force-bounce/dist/d3-force-bounce.min.js"></script>
<script src="//unpkg.com/d3-force-surface/dist/d3-force-surface.min.js"></script>
<script src="node_modules/underscore/underscore.js"></script>
<script>
    var setting, nodes, simulation_main, space_group, main, node_main, subspace;
    var simulation_school, school, node_school, routine_school;
    var simulation_hospital, hospital, node_hospital;
    var simulation_interval;
    var simulation;

    const state = {
        S: "green", // Susceptible
        E: "yellow", // Exposed, latent period
        I: "red",
        H: "grey",
        R: "blue" // Removed state
    };

    // Create nodes and assign initial values
    const createNodes = function() {
        let _nodes = [];

        // Assigns coordinate for each node
        let corr_list = [];
        _.range(0,setting.main.width * setting.size).forEach((i) => {
            _.range(0, setting.main.height * setting.size).forEach((j) => {
                corr_list.push([i / setting.size, j / setting.size]);
            })})
        corr_list = _.sample(corr_list, setting.node_num);

        // Assigns age factor for each node
        let age_list = _.range(0, setting.node_num);
        let age_count = 0;
        for (let i = 0; i < setting.age_factor.length; i++) {
            let age_count_temp = Math.ceil(setting.age_factor[i].population_ratio * setting.node_num);
            if (age_count + age_count_temp > setting.node_num) age_count_temp = setting.node_num - age_count;
            age_list.fill(setting.age_factor[i].age, age_count, age_count + Math.ceil(age_count_temp));
            age_count += age_count_temp;
        }
        age_list = _.shuffle(age_list);

        // Initialize node value
        for (let i = 0; i < setting.node_num; i++) {
            let angle = Math.random() * 2 * Math.PI;
            _nodes.push({
                index: i,
                x: corr_list[i][0],
                y: corr_list[i][1],
                vx: setting.speed * Math.cos(angle),
                vy: setting.speed * Math.sin(angle),
                state: state.S,
                age: age_list[i],
                mask: false,
                loc: "main",

                infect: function() {
                    if (this.state !== state.S) return;
                    let latent_period = setting.latent_period[0] + Math.random() * (setting.latent_period[1] - setting.latent_period[0]);
                    let infect_period = setting.infect_period[0] + Math.random() * (setting.infect_period[1] - setting.infect_period[0]);
                    this.state = state.E;
                    setTimeout(() => {
                        this.state = state.I;
                        setTimeout(() => {
                            this.state = state.R;
                            this.loc = "main";
                            this.x = this.x / setting.hospital.width * setting.main.width;
                            this.y = this.y / setting.hospital.height * setting.main.height;
                        }, infect_period * 1000);
                        if (Math.random() > setting.hospitalized_rate) {
                            setTimeout(() => {
                                if (this.loc === "main") {
                                    this.x = this.x / setting.main.width * setting.hospital.width;
                                    this.y = this.y / setting.main.height * setting.hospital.height;
                                }
                                this.state = state.H;
                                this.loc = "hospital";
                            }, 1000)
                        }
                    }, latent_period * 1000)
                }
            })
        }

        // console.log(_nodes);
        return _nodes;
    }


    function start_simulation() {
        // Get setting values
        setting = {
            main: {height: 600, width: 800}, school: {height: 150, width: 200}, hospital: {height: 150, width: 200},
            node_num: parseInt(d3.select("#node_num_output").text()),
            speed: parseFloat(d3.select("#initial_speed_output").text()),
            size: parseInt(d3.select("#size_output").text()),
            initial_patient: parseInt(d3.select("#initial_patient_output").text()),
            age_factor: _.map(_.zip(
                _.range(10,71,10), // Age
                _.range(10,71,10).map(e=> parseFloat(d3.select("#pop_" + e.toString()).node().value)), // Population
                _.range(10,71,10).map(e=> parseFloat(d3.select("#Imm_" + e.toString()).node().value)) // TPC_multiplier: How much is this group strong against the ill?
                ), e => _.object(["age", "population", "TPC_multiplier"], e)
            ),
            mask_ratio: parseFloat(d3.select("#mask_ratio_output").text()), // Mask_ratio: How many of this age group wears mask?
            latent_period: [parseFloat(d3.select("#latent_period_min_output").text()),parseFloat(d3.select("#latent_period_max_output").text())],
            infect_period: [parseFloat(d3.select("#duration_min_output").text()), parseFloat(d3.select("#duration_max_output").text())],
            mask_factor: 0.3, // 1 means no effect by mask, 0 means perfect prevention
            TPC_base: parseFloat(d3.select('#transmission_rate_output').text()), // Transmission per contact, 1 means transmission occurs 100% per contact, 0 means no transmission
            hospitalized_rate: parseFloat(d3.select("#hospitalization_output").text()), // How much patients are hospitalized?
            social_distancing_strength: parseFloat(d3.select("#social_distancing_output").text())
        };

        setting.age_factor.forEach(e => {
            e.population_ratio = e.population / setting.age_factor.reduce((acc, cur) => acc + cur.population,0);
        })

        const TPC = function(node1, node2) {
            let tpc = setting.TPC_base;
            tpc *= _.find(setting.age_factor, function(d) { return d.age === node1.age;}).TPC_multiplier;
            tpc *= _.find(setting.age_factor, function(d) { return d.age === node2.age;}).TPC_multiplier;
            if (node1.mask) tpc *= setting.mask_factor;
            if (node2.mask) tpc *= setting.mask_factor;
            return tpc;
        }

        // Setting data
        nodes = createNodes();
        _.sample(nodes,setting.mask_ratio)
        _.sample(nodes,setting.initial_patient).forEach(node => {node.infect();},this);

        function collision (node1, node2) {
            // Collision event
            if (node1.state === state.S && (node2.state === state.E || node2.state === state.I)) {
                if (Math.random() < TPC(node1,node2)) {
                    node1.infect();
                }
            }
            else if ((node1.state === state.E || node1.state === state.I) && node2.state === state.S) {
                if (Math.random() < TPC(node1,node2)) {
                    node2.infect();
                }
            }
        }

        simulation_main = d3.forceSimulation(nodes.filter(e=>e.loc === "main"))
            .alphaDecay(0)
            .velocityDecay(0)
            .force("bounce", d3.forceBounce()
                .radius(setting.size)
                .elasticity(1)
                .onImpact(collision))
            .force("surface", d3.forceSurface()
                .elasticity(1)
                .surfaces([
                    {from: {x:0, y:-5}, to: {x:0, y:setting.main.height+5}},
                    {from: {x:-5, y:setting.main.height}, to: {x:setting.main.width+5, y:setting.main.height}},
                    {from: {x:setting.main.width, y:setting.main.height+5}, to: {x:setting.main.width, y:-5}},
                    {from: {x:setting.main.width+5, y:0}, to: {x:-5, y:0}},
                ])
                .oneWay(false))
            .force("charge", d3.forceManyBody()
                .strength(-1 * setting.social_distancing_strength)
                .distanceMax(setting.size * 10));

        simulation_school = d3.forceSimulation(nodes.filter(e=>e.loc === "school"))
            .alphaDecay(0)
            .velocityDecay(0)
            .force("bounce", d3.forceBounce()
                .radius(setting.size)
                .elasticity(0)
                .onImpact(collision))
            .force("surface", d3.forceSurface()
                .elasticity(1)
                .surfaces([
                    {from: {x:0, y:-5}, to: {x:0, y:setting.school.height+5}},
                    {from: {x:-5, y:setting.school.height}, to: {x:setting.school.width+5, y:setting.school.height}},
                    {from: {x:setting.school.width, y:setting.school.height+5}, to: {x:setting.school.width, y:-5}},
                    {from: {x:setting.school.width+5, y:0}, to: {x:-5, y:0}},
                ])
                .oneWay(false))

        simulation_hospital = d3.forceSimulation(nodes.filter(e=>e.loc === "hospital"))
            .alphaDecay(0)
            .velocityDecay(0)
            .force("bounce", d3.forceBounce()
                .radius(setting.size)
                .elasticity(0)
                .onImpact(collision))
            .force("surface", d3.forceSurface()
                .elasticity(1)
                .surfaces([
                    {from: {x:0, y:-5}, to: {x:0, y:setting.hospital.height+5}},
                    {from: {x:-5, y:setting.hospital.height}, to: {x:setting.hospital.width+5, y:setting.hospital.height}},
                    {from: {x:setting.hospital.width, y:setting.hospital.height+5}, to: {x:setting.hospital.width, y:-5}},
                    {from: {x:setting.hospital.width+5, y:0}, to: {x:-5, y:0}},
                ])
                .oneWay(false))

        space_group = d3.select("body").append("div")
            .attr("width", setting.main.width + setting.school.width + 20)
            .attr("height", setting.main.height + 20)
            .attr("class","space_group");

        main = space_group.append("div").append("svg")
                .attr("width", setting.main.width)
                .attr("height", setting.main.height)
                .attr("id", "main");

        subspace = space_group.append("g")
            .attr("class","subspaces")
            .attr("id","subspaces");
        
        // School
        school = subspace.append("div")
                .attr("class", "subspace")
                .attr("id", "div_school");
        school.append("svg")
                    .attr("width", setting.school.width)
                    .attr("height", setting.school.height)
                    .attr("id", "svg_school");
        school.append("p").text("School");
        
        // Hospital
        hospital = subspace.append("div")
            .attr("class", "subspace")
            .attr("id", "div_hospital");
        hospital.append("svg")
            .attr("width", setting.hospital.width)
            .attr("height", setting.hospital.height)
            .attr("id", "svg_hospital");
        hospital.append("p").text("Hospital");
        
        
        function go_school() {
            nodes.forEach(e => {
                if (e.age < 20 && e.loc !== "hospital") {
                    e.loc = "school";
                    e.x = e.x / setting.main.width * setting.school.width;
                    e.y = e.y / setting.main.height * setting.school.height;
                    setTimeout(function() {
                        if (e.loc !== "hospital") {
                            e.loc = "main";
                            e.x = e.x / setting.school.width * setting.main.width;
                            e.y = e.y / setting.school.height * setting.main.height;
                        }
                    }, 2000)
                }
            });
        }

        node_main = main.append("g")
            .attr("class","nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("stroke","black");

        node_school = school.select("#svg_school")
            .append("g")
            .attr("class","nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("stroke","black");

        node_hospital = hospital.select("#svg_hospital")
            .append("g")
            .attr("class","nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("stroke","black");

        function ticked() {
            nodes.forEach(e => {
                e.fx = null;
                e.fy = null;
            })
            nodes.forEach(e => {
                if (e.loc === "main") {
                    if (e.x > setting.main.width+5) e.fx = setting.main.width * 0.9;
                    if (e.x < -5) e.fx = setting.main.width * 0.1;
                    if (e.y > setting.main.height+5) e.fy = setting.main.height * 0.9;
                    if (e.y < -5) e.fy = setting.main.height * 0.1;
                }
                if (e.loc === "school") {
                    if (e.x > setting.school.width+5) e.fx = setting.school.width * 0.9;
                    if (e.x < -5) e.fx = setting.school.width * 0.1;
                    if (e.y > setting.school.height+5) e.fy = setting.school.height * 0.9;
                    if (e.y < -5) e.fy = setting.school.height * 0.1;
                }
                if (e.loc === "hospital") {
                    if (e.x > setting.hospital.width+5) e.fx = setting.hospital.width * 0.9;
                    if (e.x < -5) e.fx = setting.hospital.width * 0.1;
                    if (e.y > setting.hospital.height+5) e.fy = setting.hospital.height * 0.9;
                    if (e.y < -5) e.fy = setting.hospital.height * 0.1;
                }
            })
            node_main
                .attr("cx", function(d) {
                    return d.x;
                })
                .attr("cy", function(d) {
                    return d.y;
                })
                .attr("fill", function(d) {
                    return d.loc === "main" ? d.state : "none";
                })
                .attr("stroke", function(d) {
                    return d.loc === "main" ? "black" : "none";
                })
                .attr("r", setting.size);

            node_school
                .attr("cx", function(d) {
                    return d.x;
                })
                .attr("cy", function(d) {
                    return d.y;
                })
                .attr("fill", function(d) {
                    return d.loc === "school" ? d.state : "none";
                })
                .attr("stroke", function(d) {
                    return d.loc === "school" ? "black" : "none";
                })
                .attr("r", setting.size);

            node_hospital
                .attr("cx", function(d) {
                    return d.x;
                })
                .attr("cy", function(d) {
                    return d.y;
                })
                .attr("fill", function(d) {
                    return d.loc === "hospital" ? d.state : "none";
                })
                .attr("stroke", function(d) {
                    return d.loc === "hospital" ? "black" : "none";
                })
                .attr("r", setting.size);
        }

        routine_school = setInterval(go_school, 4000);
        simulation_interval = setInterval(function() {
            ticked();
            simulation_main.nodes(nodes.filter(e=>e.loc==="main"));
            simulation_school.nodes(nodes.filter(e=>e.loc==="school"));
            simulation_hospital.nodes(nodes.filter(e=>e.loc==="hospital"))
            simulation_main.tick();
            simulation_school.tick();
            simulation_hospital.tick();
        }, 16.67)

    }
    function stop_simulation() {
        if (simulation_interval) {clearInterval(simulation_interval); simulation_interval = null;}
        if (routine_school) {clearInterval(routine_school); routine_school = null;}
    }
    function reset_simulation() {
        d3.select("div.space_group").remove();
    }
</script>
</html>